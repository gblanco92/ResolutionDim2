needs "puiseuxSeries.m2"

squareFreePart = method(TypicalValue => RingElement);
squareFreePart (RingElement) := (f) -> (
  y := last generators ring f;
  return f//gcd(f, diff(y, f));
)

squareFreeFactorization = method(TypicalValue => List);
squareFreeFactorization (RingElement) := (f) -> (
  -- Yun's algorithm
  y := last generators ring f;
  d := diff(y, f);
  squareFree := {};
  while degree f != {0} do (
    a := gcd(f, d);
    f = f//a;
    d = d//a - diff(y, f);
    squareFree = append(squareFree, a);
  );
  squareFree = drop(squareFree, 1);
  return apply(select(pack(2, mingle(squareFree, 1..#squareFree)),
    fact -> not isConstant fact#0), toSequence);
)

ZZ * InfiniteNumber := (n, inf) -> if n == 0 then 0 else
  if n > 0 then infinity else -infinity;

ccwTurn = method(TypicalValue => Boolean);
ccwTurn (BasicList, BasicList, BasicList) := (p1, p2, p3) -> (
  return (p2#0 - p1#0)*(p3#1 - p1#1) - (p2#1 - p1#1)*(p3#0 - p1#0) <= 0;
)

newtonPolygon = method(TypicalValue => List);
newtonPolygon (RingElement) := (f) -> (
  pol := {};
  apply(sort exponents f | {{infinity, 0}}, p -> (
    while (#pol >= 2 and ccwTurn(pol#(#pol - 2), pol#(#pol - 1), p)) do
      pol = drop(pol, -1);
    pol = append(pol, p);
  )); return drop(pol, -1);
)

newtonSide = method(TypicalValue => Sequence);
newtonSide (List, List, RingElement) := (p, q, f) -> (
  g := gcd(p#1 - q#1, q#0 - p#0);
  n := (p#1 - q#1)//g;
  m := (q#0 - p#0)//g;
  k := (p#1*q#0 - p#0*q#1)//g;

  -- Select which exponents are on the side generated by p & q.
  use ZZ[local X, local Y];
  side := n*X + m*Y - k;
  onSide := sort select(listForm f, (e, A) -> sub(side, {X=>e#0, Y=>e#1}) == 0);

  -- Construct the equation associated with the pq side.
  bits := precision ring f;
  use CC_bits[local Z];
  beta0 := (last onSide)#0#1;
  return (m, n, k, sum apply(onSide, (e, A) -> A*Z^((e#1 - beta0)//n)));
)

newtonSides = method(TypicalValue => List);
newtonSides (RingElement, List) := (f, points) -> (
  numSides := #points - 1;
  return apply(points_{0..numSides-1}, points_{1..numSides}, (p, q) ->
           newtonSide(p, q, f));
)

puiseuxExpansion = method(TypicalValue => List,
                          Options => { Terms => -1,
                                       Bits => 300 });
puiseuxExpansion (RingElement) := opts -> (f) -> (
  if not isPolynomialRing ring f then error "not a polynomial";
  if numgens ring f != 2 then error "not a bivariate polynomial";
  R := coefficientRing ring f;
  if R =!= ZZ and R =!= QQ then error "coefficient ring must be ZZ or QQ";
  z := first generators ring f; w := last generators ring f;
  use CC_(2*opts.Bits)[local x, local y];

  Nf := newtonPolygon f;
  yBranch := {};
  -- If Nf starts on the right of the y-axis, we have an x-factor.
  if (first Nf)#0 > 0 then yBranch = { (x, (first Nf)#0) };

  V := {z => x, w => y};
  return yBranch | apply(puiseuxExpansionLoop(sub(squareFreePart(f), V),
    apply(squareFreeFactorization(f), (g, m) -> (sub(g, V), m, 1)), opts.Terms),
      s -> (s#0, s#1#0#1));
)

puiseuxExpansion (List) := opts -> (L) -> (
  if not all(L, f -> numgens ring f == 2) then
    error "not bivariate polynomials";
  R := coefficientRing ring L#0;
  if R =!= ZZ and R =!= QQ then error "coefficient ring must be ZZ or QQ";
  z := first generators ring L#0; w := last generators ring L#0;
  use CC_(2*opts.Bits)[local x, local y];

  f := product L;
  Nf := newtonPolygon f;
  yBranch := {};
  -- If Nf starts on the right of the y-axis, we have an x-factor.
  if (first Nf)#0 > 0 then yBranch = { (x, select(apply(L, 1..#L, (g, i) ->
      (i, (first newtonPolygon g)#0)), (i, m) -> m != 0)) };

  V := {z => x, w => y};
  sqFreePart := sub(squareFreePart(f), V);
  sqFreeFact := flatten apply(apply(L, l -> apply(squareFreeFactorization l,
    (g, m) -> (sub(g, V), m))), 1..#L, (l, i) -> apply(l, (g, m) -> (g, m, i)));
  return yBranch | apply(puiseuxExpansionLoop(sqFreePart, sqFreeFact, -1),
    s -> (s#0, s#1));
)

puiseuxExpansionLoop = method(TypicalValue => List);
puiseuxExpansionLoop (RingElement, List, ZZ) := (f, L, num) -> (
  x := first generators ring f;
  y := last generators ring f;
  eps := 2.0^(-(precision ring f)/2);
  -- Select only those factors that contain the current branch.
  L = select(L, (g, m, i) -> (first newtonPolygon g)#1 != 0);

  Nf := newtonPolygon f;
  -- If the height is 1 we can stop here as this branch has been
  -- separated from the rest. (Except if more terms have been requested.)
  if (num < 0 and (first Nf)#1 == 1) or num == 0 then
    return { ((0*x)^(1_QQ), apply(L, (g, m, i) -> (i, m))) };

  -- Step (i.a): Select only those factors containing the 0 branch.
  if (last Nf)#1 > 0 then exactBranch := { ((0*x)^(1_QQ), apply(select(L,
    (g, m, i) -> (last newtonPolygon g)#1 > 0), (g, m, i) -> (i, m))) }
  else exactBranch = {};
  -- Step (i.b): For each side...
  return exactBranch | flatten apply(newtonSides(f, Nf), (m, n, k, F) ->
    -- For each root...
    flatten apply(unique(roots(F)), a -> (
      -- Get the solution, do & undo the change of variables.
      newVar := { x => x^n, y => x^m*(a^(1/n) + y) };
      apply(puiseuxExpansionLoop(
          clean(eps, sub(f, newVar)), apply(L, (g, m, i) ->
            (clean(eps, sub(g, newVar)), m, i)), num - 1),
        (s, i) -> (x^(m/n)*(a + sub(s, x => x^(1/n))), i))
    ))
  );
)
